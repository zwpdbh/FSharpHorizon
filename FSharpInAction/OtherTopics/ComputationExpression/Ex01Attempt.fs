module Tests

open Expecto


// Create a simplest workflow in which  failure of a computation is made explicit; for example,
// in which each step of the workflow may either succeed, by returning a result Some(v), or fail, by returning
// the value None. Y


// Whenever you define a new kind of workflow, it is useful to give a name to
// the type of values or objects generated by that workflow.

// Here, let's call them Attempt object
type Attempt<'T> = (unit -> 'T option)


// An example of type signature for this builder object
//type AttemptBuilder =
//    member Bind : p:Attempt<'T> * ('T -> Attempt<'U>) -> Attempt<'U>
//    member Delay : f:(unit -> Attempt<'T>) -> Attempt<'T>
//    member Return : x:'T -> Attempt<'T>
//    member ReturnFrom : x:Attempt<'T> -> Attempt<'T>


// Let's  implement the computation-expression builder for Attempt computation expressions
let succeed x = fun () -> Some x

let fail = fun () -> None

let runAttempt (a: Attempt<'T>) = a ()

let bind p rest =
    match runAttempt p with
    | None -> fail
    | Some r -> rest r

let delay f = fun () -> runAttempt (f ())

let combine p1 p2 =
    fun () ->
        match p1 () with
        | None -> p2 ()
        | res -> res


type AttempBuilder() =
    /// Used to de-sugar uses of 'let!' inside computation expressions
    member x.Bind(p, rest) = bind p rest

    /// Delays the construction of an attempt until just before it is executed
    member x.Delay f = delay f

    /// Used to de-sugar uses of 'return' inside computation expressions
    member x.Return a = succeed a

    /// Used to de-sugar uses of 'return!' inside computation expressions
    member x.ReturnFrom(a: Attempt<'T>) = a

    /// Used to de-sugar uses of 'c1; c2' inside computation expressions.
    member x.Combine(p1: Attempt<'T>, p2: Attempt<'T>) = combine p1 p2

    /// Used to de-sugar uses of 'if .. then ..' inside computation expressions when the 'else' branch is empty
    member b.Zero() = fail


let attempt = new AttempBuilder()


let failIfBig n =
    attempt {
        if n > 1000 then
            return! fail
        else
            return n
    }

let failIfEitherBig (inp1, inp2) =
    attempt {
        let! n1 = failIfBig inp1
        let! n2 = failIfBig inp2

        return (n1, n2)
    }

let test01 = testCase "01" <| fun _ -> 
    Expect.equal (runAttempt (failIfEitherBig (999, 998))) (Some (999, 998)) ""
    Expect.isTrue true ""



let sumIfBothSmall (inp1, inp2) = 
    attempt {
        let! n1 = failIfBig inp1 
        let! n2 = failIfBig inp2 
        return n1 + n2
    }

let test02 = 
    testCase "02" 
    <| fun _ -> 
        Expect.equal (runAttempt (sumIfBothSmall (100, 200))) (Some 300) ""
        Expect.equal ((sumIfBothSmall (1001, 200)) |> runAttempt) None ""

[<Tests>]
let tests = testList "Computation Expression: AttempBuilder" [ test01; test02 ]
